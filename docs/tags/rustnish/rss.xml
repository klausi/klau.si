<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>Klausi&#x27;s Weblog - rustnish</title>
      <link>https://klau.si</link>
      <description></description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://klau.si/tags/rustnish/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Sun, 31 Mar 2019 00:00:00 +0000</lastBuildDate>
      <item>
          <title>Mocking in Rust with conditional compilation</title>
          <pubDate>Sun, 31 Mar 2019 00:00:00 +0000</pubDate>
          <author>Klaus Purer</author>
          <link>https://klau.si/blog/mocking-in-rust-with-conditional-compilation/</link>
          <guid>https://klau.si/blog/mocking-in-rust-with-conditional-compilation/</guid>
          <description xml:base="https://klau.si/blog/mocking-in-rust-with-conditional-compilation/">&lt;p&gt;When writing automated unit tests for your application you will probably need to use &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mock_object&quot;&gt;mocks&lt;&#x2F;a&gt; at some point. Classical object-oriented programming languages such as PHP solve this with reflection where mock object types are created during test runtime. The code under test expects a certain interface or class and the test code passes mock objects that implement the interface or are a subclass.&lt;&#x2F;p&gt;
&lt;p&gt;Similar approaches exist in Rust where mock objects are used to test code that expects a trait type. There is a wonderful &lt;a href=&quot;https:&#x2F;&#x2F;asomers.github.io&#x2F;mock_shootout&#x2F;&quot;&gt;Rust mock framework comparison&lt;&#x2F;a&gt; by Alan Somers that lists their features. The biggest problem with most of them as far as I can see is that they cannot mock a foreign &lt;code&gt;struct&lt;&#x2F;code&gt; you are using in your code. Rust does not have a concept of object inheritance for structs so there is no way to mimic a struct type from the standard library or an external crate.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Benchmarking a Rust web application</title>
          <pubDate>Fri, 31 Aug 2018 00:00:00 +0000</pubDate>
          <author>Klaus Purer</author>
          <link>https://klau.si/blog/benchmarking-a-rust-web-application/</link>
          <guid>https://klau.si/blog/benchmarking-a-rust-web-application/</guid>
          <description xml:base="https://klau.si/blog/benchmarking-a-rust-web-application/">&lt;p&gt;Performance testing is an important part when developing a network application - you want to know when you have a regression in request throughput in your service.&lt;&#x2F;p&gt;
&lt;p&gt;I set out out my goal 9 for Rustnish:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Write benchmark code that compares runtime performance of Rustnish against
&lt;a href=&quot;https:&#x2F;&#x2F;varnish-cache.org&#x2F;&quot;&gt;Varnish&lt;&#x2F;a&gt;. Use &lt;code&gt;cargo bench&lt;&#x2F;code&gt; to execute the benchmarks.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;The basic idea of a performance test here is to send many HTTP requests to the web service (the reverse proxy in this case) and measure how fast the responses arrive back. Comparing the results from Rustnish and Varnish should give us an idea if our performance expectations are holding up.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Crashing a Rust Hyper server with a Denial of Service attack</title>
          <pubDate>Sun, 11 Mar 2018 00:00:00 +0000</pubDate>
          <author>Klaus Purer</author>
          <link>https://klau.si/blog/crashing-a-rust-hyper-server-with-a-denial-of-service-attack/</link>
          <guid>https://klau.si/blog/crashing-a-rust-hyper-server-with-a-denial-of-service-attack/</guid>
          <description xml:base="https://klau.si/blog/crashing-a-rust-hyper-server-with-a-denial-of-service-attack/">&lt;p&gt;I&#x27;m writing a reverse proxy in Rust using &lt;a href=&quot;https:&#x2F;&#x2F;hyper.rs&#x2F;&quot;&gt;Hyper&lt;&#x2F;a&gt; and I want
to measure performance a bit to know if I&#x27;m doing something terribly wrong. By
doing that I discovered a Denial of Service vulnerability in Hyper when IO
errors are not properly handled. Note that &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;hyperium&#x2F;hyper&#x2F;releases&#x2F;tag&#x2F;v0.11.20&quot;&gt;a workaround has been released in
the meantime in Hyper
0.11.20&lt;&#x2F;a&gt;, more
background info can be found in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;hyperium&#x2F;hyper&#x2F;issues&#x2F;1358&quot;&gt;this Hyper
issue&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Testing memory leaks in Rust</title>
          <pubDate>Fri, 06 Oct 2017 00:00:00 +0000</pubDate>
          <author>Klaus Purer</author>
          <link>https://klau.si/blog/testing-memory-leaks-in-rust/</link>
          <guid>https://klau.si/blog/testing-memory-leaks-in-rust/</guid>
          <description xml:base="https://klau.si/blog/testing-memory-leaks-in-rust/">&lt;p&gt;Rust has many built-in concepts for memory safety, but it cannot prevent
application level logic errors that take up system memory. An example would be
a server application that stores something for each incoming request in a
growing collection or list. If the program does not clean up the growing list
then it will take up more and more server memory - thereby exposing a memory
leak.&lt;&#x2F;p&gt;
&lt;p&gt;While working on my reverse proxy project I discovered such a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;hyperium&#x2F;hyper&#x2F;issues&#x2F;1315&quot;&gt;leak in the HTTP
library Hyper&lt;&#x2F;a&gt;. In order to
prevent and detect memory leaks in the future I set out my goal 7:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Add an integration test that ensures that the proxy server is not leaking
memory (growing RAM usage without shrinking again). Use &#x2F;proc information to
compare memory usage of the current process before and after the test.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</description>
      </item>
      <item>
          <title>Static variables made thread-safe in Rust</title>
          <pubDate>Sat, 09 Sep 2017 00:00:00 +0000</pubDate>
          <author>Klaus Purer</author>
          <link>https://klau.si/blog/static-variables-made-thread-safe-in-rust/</link>
          <guid>https://klau.si/blog/static-variables-made-thread-safe-in-rust/</guid>
          <description xml:base="https://klau.si/blog/static-variables-made-thread-safe-in-rust/">&lt;p&gt;When writing &lt;a href=&quot;https:&#x2F;&#x2F;klau.si&#x2F;blog&#x2F;writing-integration-tests-in-rust&#x2F;&quot;&gt;integration tests for my Rustnish reverse proxy project&lt;&#x2F;a&gt; I
have hard-coded port numbers in tests. This is not ideal because it is hard to
keep track of which port numbers have already been used and which ones are
available when writing a new test. Because Rust&#x27;s test runner &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch11-02-running-tests.html#running-tests-in-parallel-or-consecutively&quot;&gt;executes test cases in parallel&lt;&#x2F;a&gt; it is important to coordinate
which test uses which ports so that there are no clashes that break the tests.&lt;&#x2F;p&gt;
&lt;p&gt;One obvious solution to this problem would be to disable parallel test
execution with &lt;code&gt;cargo test -- --test-threads=1&lt;&#x2F;code&gt;. But we want to cover program
and test isolation with our test so this is not really an option.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Replacing unwrap() and avoiding panics in Rust</title>
          <pubDate>Wed, 16 Aug 2017 00:00:00 +0000</pubDate>
          <author>Klaus Purer</author>
          <link>https://klau.si/blog/replacing-unwrap-and-avoiding-panics-in-rust/</link>
          <guid>https://klau.si/blog/replacing-unwrap-and-avoiding-panics-in-rust/</guid>
          <description xml:base="https://klau.si/blog/replacing-unwrap-and-avoiding-panics-in-rust/">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;result&#x2F;enum.Result.html#method.unwrap&quot;&gt;&lt;code&gt;unwrap()&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; is a useful tool in Rust but is also bad practice in production code that
should not abort with unpredictable panics.&lt;&#x2F;p&gt;
&lt;p&gt;Therefore my goal 4 for Rustnish is full integration tests with no panics
allowed:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Expand the integration tests to confirm that the reverse proxy is working as
expected. Add tests with broken HTTP requests to cover error handling of the
reverse proxy. All &lt;code&gt;unwrap()&lt;&#x2F;code&gt; calls in none test code should be removed
and covered by proper error handling.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</description>
      </item>
      <item>
          <title>Converting a Hyper server to Tokio</title>
          <pubDate>Sun, 16 Jul 2017 00:00:00 +0000</pubDate>
          <author>Klaus Purer</author>
          <link>https://klau.si/blog/converting-a-hyper-server-to-tokio/</link>
          <guid>https://klau.si/blog/converting-a-hyper-server-to-tokio/</guid>
          <description xml:base="https://klau.si/blog/converting-a-hyper-server-to-tokio/">&lt;p&gt;Since my &lt;a href=&quot;https:&#x2F;&#x2F;klau.si&#x2F;blog&#x2F;getting-started-with-rust&#x2F;&quot;&gt;first blog post where I constructed a server with Hyper&lt;&#x2F;a&gt; some time
has passed and there is now a new version of the library that is based on
&lt;a href=&quot;https:&#x2F;&#x2F;tokio.rs&quot;&gt;Tokio&lt;&#x2F;a&gt;. My goal 3:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A new version of the Hyper library has been released which is
based on the Tokio library. Convert the existing code to use that new version
and provide one integration test case.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Tokio handles input&#x2F;output asynchronously, which makes setting up a server more
complicated. The benefit is more efficient parallel execution with a
non-blocking event loop.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Using Visual Studio Code for Rust on Ubuntu</title>
          <pubDate>Sun, 28 May 2017 00:00:00 +0000</pubDate>
          <author>Klaus Purer</author>
          <link>https://klau.si/blog/using-visual-studio-code-for-rust-on-ubuntu/</link>
          <guid>https://klau.si/blog/using-visual-studio-code-for-rust-on-ubuntu/</guid>
          <description xml:base="https://klau.si/blog/using-visual-studio-code-for-rust-on-ubuntu/">&lt;p&gt;I already wrote about &lt;a href=&quot;https:&#x2F;&#x2F;klau.si&#x2F;blog&#x2F;using-eclipse-ide-for-rust-on-ubuntu&#x2F;&quot;&gt;using Eclipse for Rust development&lt;&#x2F;a&gt; but after trying
&lt;a href=&quot;https:&#x2F;&#x2F;code.visualstudio.com&#x2F;&quot;&gt;Visual Studio Code&lt;&#x2F;a&gt; (VSCode) I think it is
slightly better than the Eclipse integration:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;when the cursor is at a variable the same variable is highlighted elsewhere.&lt;&#x2F;li&gt;
&lt;li&gt;tooltip popups when hovering over variables, functions, methods.&lt;&#x2F;li&gt;
&lt;li&gt;better native support for Git and Markdown files&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Syntax highlighting, autocompletion, Ctrl + Click on functions and
auto-formatting of course also work in VSCode as you would expect from an IDE.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Writing integration tests in Rust</title>
          <pubDate>Thu, 25 May 2017 00:00:00 +0000</pubDate>
          <author>Klaus Purer</author>
          <link>https://klau.si/blog/writing-integration-tests-in-rust/</link>
          <guid>https://klau.si/blog/writing-integration-tests-in-rust/</guid>
          <description xml:base="https://klau.si/blog/writing-integration-tests-in-rust/">&lt;p&gt;In my first post I wrote a quite fragile, minimally working prototype that uses
many &lt;code&gt;unwrap()&lt;&#x2F;code&gt; calls thereby raising lots of panics during execution.
Implementing and verifying proper error handling requires testing. I don&#x27;t want
to do unit testing yet because that would require research about complicated
mocking techniques and dependency injection in Rust. Instead, I would like to
do integration testing of the whole application to prove that the end result is
working as expected.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Using Eclipse IDE for Rust on Ubuntu</title>
          <pubDate>Sat, 06 May 2017 00:00:00 +0000</pubDate>
          <author>Klaus Purer</author>
          <link>https://klau.si/blog/using-eclipse-ide-for-rust-on-ubuntu/</link>
          <guid>https://klau.si/blog/using-eclipse-ide-for-rust-on-ubuntu/</guid>
          <description xml:base="https://klau.si/blog/using-eclipse-ide-for-rust-on-ubuntu/">&lt;p&gt;&lt;strong&gt;Update: &lt;a href=&quot;https:&#x2F;&#x2F;klau.si&#x2F;blog&#x2F;using-visual-studio-code-for-rust-on-ubuntu&#x2F;&quot;&gt;New blog post about choosing Visual Studio Code for Rust&lt;&#x2F;a&gt;
because of better IDE support.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In &lt;a href=&quot;https:&#x2F;&#x2F;klau.si&#x2F;blog&#x2F;getting-started-with-rust&#x2F;&quot;&gt;my first blog post&lt;&#x2F;a&gt; I was
starting out with Atom editor but quickly realized that it is lacking features
of Integrated Development Environments (IDEs). I need to be able to click on
functions and data types to jump to their definitions and was not able to get
that working in Atom.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Getting started with Rust</title>
          <pubDate>Sun, 30 Apr 2017 00:00:00 +0000</pubDate>
          <author>Klaus Purer</author>
          <link>https://klau.si/blog/getting-started-with-rust/</link>
          <guid>https://klau.si/blog/getting-started-with-rust/</guid>
          <description xml:base="https://klau.si/blog/getting-started-with-rust/">&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;klau.si&#x2F;blog&#x2F;getting-started-with-rust&#x2F;rustnish2.png&quot; alt=&quot;Rustnish logo&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&quot;&gt;Rust&lt;&#x2F;a&gt; is still very alien to me and I want to write
a bit of code in it to get a feeling of the concepts and restrictions it
enforces.&lt;&#x2F;p&gt;</description>
      </item>
    </channel>
</rss>
